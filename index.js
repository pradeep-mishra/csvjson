
module.exports = {
    toObject: toObject,
    toArray: toArray,
    toColumnArray: toColumnArray,
    toSchemaObject: toSchemaObject,
    toCSV: toCSV
}


function toColumnArray(data, opts) {

    opts = opts || {};

    var delimiter = (opts.delimiter || ',');
    var quote = _getQuote(opts.quote);
    var content = data;
    var headers = null;

    if (typeof (content) !== "string") {
        throw new Error("Invalid input, input data should be a string");
    }

    content = content.split(/[\n\r]+/ig);

    if (typeof (opts.headers) === "string") {
        headers = opts.headers.split(/[\n\r]+/ig);
        headers = quote ?
            _convertArray(headers.shift(), delimiter, quote) :
            headers.shift().split(delimiter);
    } else {
        headers = quote ?
            _convertArray(content.shift(), delimiter, quote) :
            content.shift().split(delimiter);
    }


    var hashData = {};

    headers.forEach(function (item) {
        hashData[item] = [];
    });

    content.forEach(function (item) {
        if (item) {
            item = quote ?
                _convertArray(item, delimiter, quote) :
                item.split(delimiter);
            item.forEach(function (val, index) {
                hashData[headers[index]].push(_trimQuote(val));
            });
        }
    });

    return hashData;
}

function toObject(data, opts) {

    opts = opts || {};

    var delimiter = (opts.delimiter || ',');
    var quote = _getQuote(opts.quote);
    var content = data;
    var headers = null;

    if (typeof (content) !== "string") {
        throw new Error("Invalid input, input data should be a string");
    }

    content = content.split(/[\n\r]+/ig);

    if (typeof (opts.headers) === "string") {
        headers = opts.headers.split(/[\n\r]+/ig);
        headers = quote ?
            _convertArray(headers.shift(), delimiter, quote) :
            headers.shift().split(delimiter);
    } else {
        headers = quote ?
            _convertArray(content.shift(), delimiter, quote) :
            content.shift().split(delimiter);
    }

    var hashData = [];

    content.forEach(function (item) {
        if (item) {
            item = quote ?
                _convertArray(item, delimiter, quote) :
                item.split(delimiter);
            var hashItem = {};
            headers.forEach(function (headerItem, index) {
                hashItem[headerItem] = _trimQuote(item[index]);
            });
            hashData.push(hashItem);
        }
    });
    return hashData;
}

function toSchemaObject(data, opts) {

    opts = opts || {};

    var delimiter = (opts.delimiter || ',');
    var quote = _getQuote(opts.quote);
    var content = data;
    var headers = null;
    if (typeof (content) !== "string") {
        throw new Error("Invalid input, input should be a string");
    }

    content = content.split(/[\n\r]+/ig);


    if (typeof (opts.headers) === "string") {
        headers = opts.headers.split(/[\n\r]+/ig);
        headers = quote ?
            _convertArray(headers.shift(), delimiter, quote) :
            headers.shift().split(delimiter);
    } else {
        headers = quote ?
            _convertArray(content.shift(), delimiter, quote) :
            content.shift().split(delimiter);
    }


    var hashData = [];

    content.forEach(function (item) {
        if (item) {
            item = quote ?
                _convertArray(item, delimiter, quote) :
                item.split(delimiter);
            var schemaObject = {};
            item.forEach(function (val, index) {
                _putDataInSchema(headers[index], val, schemaObject, delimiter, quote);
            });
            hashData.push(schemaObject);
        }
    });

    return hashData;
}

function toArray(data, opts) {

    opts = opts || {};

    var delimiter = (opts.delimiter || ',');
    var quote = _getQuote(opts.quote);
    var content = data;

    if (typeof (content) !== "string") {
        throw new Error("Invalid input, input data should be a string");
    }

    content = content.split(/[\n\r]+/ig);
    var arrayData = [];
    content.forEach(function (item) {
        if (item) {
            item = quote ?
                _convertArray(item, delimiter, quote) :
                item.split(delimiter);

            item = item.map(function (cItem) {
                return _trimQuote(cItem);
            });
            arrayData.push(item);
        }
    });
    return arrayData;
}

function _getQuote(q) {
    if (typeof (q) === "string") {
        return q;
    } else if (q === true) {
        return '"';
    }
    return null;
}

function _dataType(arg) {
    if (arg === null) {
        return 'null';
    }
    else if (arg && (arg.nodeType === 1 || arg.nodeType === 9)) {
        return 'element';
    }
    var type = (Object.prototype.toString.call(arg)).match(/\[object (.*?)\]/)[1].toLowerCase();
    if (type === 'number') {
        if (isNaN(arg)) {
            return 'nan';
        }
        if (!isFinite(arg)) {
            return 'infinity';
        }
    }
    return type;
}

function toCSV(data, opts) {

    opts = (opts || {});
    opts.delimiter = (opts.delimiter || ',');
    opts.wrap = (opts.wrap || '');
    opts.arrayDenote = (opts.arrayDenote && String(opts.arrayDenote).trim() ? opts.arrayDenote : '[]');
    opts.objectDenote = (opts.objectDenote && String(opts.objectDenote).trim() ? opts.objectDenote : '.');
    opts.detailedOutput = (typeof (opts.detailedOutput) !== "boolean" ? true : opts.detailedOutput);
    opts.headers = String(opts.headers).toLowerCase();
    var csvJSON = {};
    var csvData = "";

    if (!opts.headers.match(/none|full|relative|key/)) {
        opts.headers = 'full';
    } else {
        opts.headers = opts.headers.match(/none|full|relative|key/)[0];
    }

    if (opts.wrap === true) {
        opts.wrap = '"';
    }

    if (typeof (data) === "string") {
        data = JSON.parse(data);
    }

    _toCsv(data, csvJSON, "", 0, opts);

    var headers = _getHeaders(opts.headers, csvJSON, opts);

    if (headers) {
        if (opts.wrap) {
            headers = headers.map(function (item) {
                return opts.wrap + item + opts.wrap;
            });
        }
        csvData = headers.join(opts.delimiter);
    }

    var bigArrayLen = _getBigArrayLength(csvJSON);
    var keys = Object.keys(csvJSON);
    var row = [];

    var replaceNewLinePattern = /\n|\r/g;
    if (!opts.wrap) {
        replaceNewLinePattern = new RegExp('\n|\r|' + opts.delimiter, 'g');
    }


    for (var i = 0; i < bigArrayLen; i++) {
        row = [];
        for (var j = 0; j < keys.length; j++) {
            if (csvJSON[keys[j]][i]) {
                csvJSON[keys[j]][i] = csvJSON[keys[j]][i].replace(replaceNewLinePattern, '\t');
                if (opts.wrap) {
                    csvJSON[keys[j]][i] = opts.wrap + csvJSON[keys[j]][i] + opts.wrap;
                }
                row[row.length] = csvJSON[keys[j]][i];
            } else {
                row[row.length] = "";
            }
        }
        csvData += '\n' + row.join(opts.delimiter);
    }
    return csvData;
}

function _toCsv(data, table, parent, row, opt) {
    if (_dataType(data) === 'undefined') {
        return _putData('', table, parent, row, opt);
    } else if (_dataType(data) === 'null') {
        return _putData('null', table, parent, row, opt);
    } else if (Array.isArray(data)) {
        return _arrayToCsv(data, table, parent, row, opt);
    } else if (typeof (data) === "object") {
        return _objectToCsv(data, table, parent, row, opt);
    } else {
        return _putData(String(data), table, parent, row, opt);
    }
}

function _putData(data, table, parent, row, opt) {
    if (!table || !table[parent]) {
        table[parent] = [];
    }
    if (row < table[parent].length) {
        row = table[parent].length;
    }
    table[parent][row] = data;
    return table;
}

function _arrayToCsv(data, table, parent, row, opt) {
    if (_doesNotContainsObjectAndArray(data)) {
        return _putData(data.join(';'), table, parent + opt.arrayDenote, row, opt);
    }
    data.forEach(function (item, index) {
        return _toCsv(item, table, parent + opt.arrayDenote, index, opt);
    });
}

function _doesNotContainsObjectAndArray(array) {
    return array.every(function (item) {
        var datatype = _dataType(item);
        if (!datatype.match(/array|object/)) {
            return true;
        }
        return false;
    });
}

function _objectToCsv(data, table, parent, row, opt) {
    Object.keys(data).forEach(function (item) {
        return _toCsv(data[item], table, parent + opt.objectDenote + item, row, opt);
    });
}

function _getHeaders(headerType, table, opt) {
    var keyMatchPattern = /([\w\s_\[\]]+)$/;
    var relativeMatchPattern = /\[\]\.?([^\[\]]+)$/;
    switch (headerType) {
        case "none":
            return null;
        case "full":
            return Object.keys(table);
        case "key":
            return Object.keys(table).map(function (header) {
                var head = header.match(keyMatchPattern);
                if (head && head.length === 2) {
                    return head[1];
                }
                return header;
            });
        case "relative":
            return Object.keys(table).map(function (header) {
                var head = header.match(relativeMatchPattern);
                if (head && head.length === 2) {
                    return head[1];
                }
                return header;
            });
    }
}

function _getBigArrayLength(table) {
    var len = 0;
    Object.keys(table).forEach(function (item) {
        if (Array.isArray(table[item]) && table[item].length > len) {
            len = table[item].length;
        }
    });
    return len;
}

function _putDataInSchema(header, item, schema, delimiter, quote) {
    var match = header.match(/\[*[\d]\]\.(\w+)|\.|\[\]|\[(.)\]|-|\+/ig);
    var headerName, currentPoint;
    if (match) {
        var testMatch = match[0];
        if (match.indexOf('-') !== -1) {
            return true;
        } else if (match.indexOf('.') !== -1) {
            var headParts = header.split('.');
            currentPoint = headParts.shift();
            schema[currentPoint] = schema[currentPoint] || {};
            _putDataInSchema(headParts.join('.'), item, schema[currentPoint], delimiter, quote);
        } else if (match.indexOf('[]') !== -1) {
            headerName = header.replace(/\[\]/ig, '');
            if (!schema[headerName]) {
                schema[headerName] = [];
            }
            schema[headerName].push(item);
        } else if (/\[*[\d]\]\.(\w+)/.test(testMatch)) {
            headerName = header.split('[').shift();
            var index = parseInt(testMatch.match(/\[(.)\]/).pop(), 10);
            currentPoint = header.split('.').pop();
            schema[headerName] = schema[headerName] || [];
            schema[headerName][index] = schema[headerName][index] || {};
            schema[headerName][index][currentPoint] = item;
        } else if (/\[(.)\]/.test(testMatch)) {
            var delimiter = testMatch.match(/\[(.)\]/).pop();
            headerName = header.replace(/\[(.)\]/ig, '');
            schema[headerName] = _convertArray(item, delimiter, quote);
        } else if (match.indexOf('+') !== -1) {
            headerName = header.replace(/\+/ig, "");
            schema[headerName] = Number(item);
        }
    } else {
        schema[header] = _trimQuote(item);
    }
    return schema;
}

function _trimQuote(str) {
    if (str) {
        return str.trim().replace(/^["|'](.*)["|']$/, '$1');
    } else return "";
}

function _convertArray(str, delimiter, quote) {
    if (quote && str.indexOf(quote) !== -1) {
        return _csvToArray(str, delimiter, quote);
    }
    var output = [];
    var arr = str.split(delimiter);
    arr.forEach(function (val) {
        var trimmed = val.trim();
        output.push(trimmed);
    });
    return output;
}

function _csvToArray(text, delimit, quote) {

    delimit = delimit || ",";
    quote = quote || '"';

    var validate = new RegExp("^\\s*(?:" + quote + "[^" + quote + "\\\\]*(?:\\\\[\\S\\s][^" + quote + "\\\\]*)*" + quote + "|[^" + delimit + quote + "\\s\\\\]*(?:\\s+[^" + delimit + quote + "\\s\\\\]+)*)\\s*(?:" + delimit + "\\s*(?:" + quote + "[^" + quote + "\\\\]*(?:\\\\[\\S\\s][^" + quote + "\\\\]*)*" + quote + "|[^," + quote + "\\s\\\\]*(?:\\s+[^" + delimit + quote + "\\s\\\\]+)*)\\s*)*$");

    var value = new RegExp("(?!\\s*$)\\s*(?:" + quote + "([^" + quote + "\\\\]*(?:\\\\[\\S\\s][^" + quote + "\\\\]*)*)" + quote + "|([^" + delimit + quote + "\\s\\\\]*(?:\\s+[^" + delimit + quote + "\\s\\\\]+)*))\\s*(?:" + delimit + "|$)", "g");

    if (!validate.test(text)) {
        return null;
    }
    var a = [];

    text.replace(value,
        function (m0, m1, m2) {
            if (m1 !== undefined) {
                a.push(m1.replace(/\\'/g, "'"));
            } else if (m2 !== undefined) {
                a.push(m2);
            }
            return '';
        }
    );

    if (/,\s*$/.test(text)) {
        a.push('');
    }
    return a;
}
